<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>SpringBoot | Iktsuarpok</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://liuyuzheng8.github.io/favicon.ico?v=1583412599581">
<link rel="stylesheet" href="https://liuyuzheng8.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="SpringBoot
什么是 SpringBoot
SpringBoot是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can &quot;just ru..." />
    <meta name="keywords" content="框架" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://liuyuzheng8.github.io">
        <img src="https://liuyuzheng8.github.io/images/avatar.png?v=1583412599581" class="site-logo">
        <h1 class="site-title">Iktsuarpok</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://liuyuzheng8.github.io/post/redis-bi-ji" class="site-nav">
            Redis
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      个人学习笔记
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://liuyuzheng8.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">SpringBoot</h2>
            <div class="post-date">2020-03-05</div>
            
            <div class="post-content" v-pre>
              <h1 id="springboot">SpringBoot</h1>
<h2 id="什么是-springboot">什么是 SpringBoot</h2>
<p>SpringBoot是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can &quot;just run&quot;，能迅速的开发web应用，几行代码开发一个http接口</p>
<p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>约定大于配置的核心思想</strong>，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用，</p>
<p>简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。</p>
<p><strong>SpringBoot 的主要优点</strong></p>
<ul>
<li>为所有Spring开发者更快的入门</li>
<li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li>
<li>内嵌式容器简化Web项目</li>
<li>没有冗余代码生成和XML配置的要求</li>
</ul>
<h2 id="第一个-springboot-程序">第一个 SpringBoot 程序</h2>
<p>官方提供了一个快速生成 SpringBoot 的网站，但是在IDEA中有集成。</p>
<p>https://start.spring.io/</p>
<h3 id="步骤">步骤：</h3>
<figure data-type="image" tabindex="1"><img src="E:%5CTypora%5CNotes%5C%E5%BE%AE%E6%9C%8D%E5%8A%A1%5CSpringBoot.assets%5Cimage-20191129092018481.png" alt="image-20191129092018481" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="E:%5CTypora%5CNotes%5C%E5%BE%AE%E6%9C%8D%E5%8A%A1%5CSpringBoot.assets%5Cimage-20191129092024760.png" alt="image-20191129092024760" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="E:%5CTypora%5CNotes%5C%E5%BE%AE%E6%9C%8D%E5%8A%A1%5CSpringBoot.assets%5Cimage-20191129092035266.png" alt="image-20191129092035266" loading="lazy"></figure>
<p>创建完成后的项目结构：</p>
<figure data-type="image" tabindex="4"><img src="E:%5CTypora%5CNotes%5C%E5%BE%AE%E6%9C%8D%E5%8A%A1%5CSpringBoot.assets%5Cimage-20191129092458783.png" alt="image-20191129092458783" loading="lazy"></figure>
<ul>
<li>程序的主程序类</li>
<li>一个 application.properties 配置文件</li>
<li>一个测试类</li>
</ul>
<p>**注意:**需要在与 Springboot1HelloworldApplication 同级的目录下进行包结构的建立.</p>
<p>pom.xml 分析：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.squid&lt;/groupId&gt;
    &lt;artifactId&gt;springboot-1-helloworld&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;springboot-1-helloworld&lt;/name&gt;
    &lt;description&gt;My First SpringBoot Project&lt;/description&gt;

    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;

</code></pre>
<p>如上所示，pom文件中主要分为四个部分：</p>
<ul>
<li>项目元数据信息：创建时候输入的Project Metadata部分，也就是Maven项目的基本元素，包括：groupId、artifactId、version、name、description等</li>
<li>parent：继承 <code>spring-boot-starter-parent</code>的依赖管理，控制版本与打包等内容</li>
<li>dependencies：项目具体依赖，这里包含了 <code>spring-boot-starter-web</code>用于实现HTTP接口（该依赖中包含了Spring MVC），官网对它的描述是：使用Spring MVC构建Web（包括RESTful）应用程序的入门者，使用Tomcat作为默认嵌入式容器。；<code>spring-boot-starter-test</code>用于编写单元测试的依赖包。更多功能模块的使用我们将在后面逐步展开。</li>
<li>build：构建配置部分。默认使用了 <code>spring-boot-maven-plugin</code> ，配合 <code>spring-boot-starter-parent</code> 就可以把Spring Boot应用打包成JAR来直接运行。</li>
</ul>
<p>SpringBoot 所有的自动配置都是在启动的时候扫描并加载,所有的自动配置类都在 spring.factories 中,但是需要判断条件是否成立,只有导入了对应的 start ,才会拥有对应的启动器,自动装配才会生效.</p>
<h2 id="配置文件">配置文件</h2>
<p>将原有的 application.properties 替换为 application.yaml。</p>
<h3 id="yaml">Yaml</h3>
<p><em>YAML</em>是&quot;YAML Ain't a Markup Language&quot;（YAML不是一种<a href="https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">标记语言</a>）的<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92%E7%BC%A9%E5%86%99">递归缩写</a></p>
<p>&quot;Yet Another Markup Language&quot;（仍是一种<a href="https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80">标记语言</a>）</p>
<h4 id="yaml的标准语法">Yaml的标准语法</h4>
<p>key：(空格)value</p>
<pre><code class="language-yaml"># 存储普通值
key: value

# 存储对象
student:
	name: squid
	age: 3
	
student: { name: squid,age: 3}

# 存储数组
pets:
	- cat
	- dog
	- pig
	
pets: [cat,dog,pig]
</code></pre>
<h3 id="yaml向实体类注入属性值">Yaml向实体类注入属性值</h3>
<pre><code class="language-java">//实体类
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {
    private String name;
    private Integer age;
    private Boolean happy;
    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; list;
    private Dog dog;

    public Person() {
    }

    public Person(String name, Integer age, Boolean happy, Date brith, Map&lt;String, Object&gt; maps, List&lt;Object&gt; list, Dog dog) {
        this.name = name;
        this.age = age;
        this.happy = happy;
        this.birth = brith;
        this.maps = maps;
        this.list = list;
        this.dog = dog;
    }

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, happy=&quot; + happy +
                &quot;, brith=&quot; + birth +
                &quot;, maps=&quot; + maps +
                &quot;, list=&quot; + list +
                &quot;, dog=&quot; + dog +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Boolean getHappy() {
        return happy;
    }

    public void setHappy(Boolean happy) {
        this.happy = happy;
    }

    public Date getBirth() {
        return birth;
    }

    public void setBirth(Date birth) {
        this.birth = birth;
    }

    public Map&lt;String, Object&gt; getMaps() {
        return maps;
    }

    public void setMaps(Map&lt;String, Object&gt; maps) {
        this.maps = maps;
    }

    public List&lt;Object&gt; getList() {
        return list;
    }

    public void setList(List&lt;Object&gt; list) {
        this.list = list;
    }

    public Dog getDog() {
        return dog;
    }

    public void setDog(Dog dog) {
        this.dog = dog;
    }
}
</code></pre>
<pre><code class="language-yaml">person:
  name: squid
  age: 3
  happy: false
  birth: 2019/11/02
  maps: {k1: v1,k2: v2}
  list:
    - code
    - music
    - girl
  dog:
    name: 旺财
    age: 3
</code></pre>
<h4 id="yaml-与-properties-文件注入的区别">Yaml 与 properties 文件注入的区别</h4>
<figure data-type="image" tabindex="5"><img src="https://img2018.cnblogs.com/blog/1418974/201907/1418974-20190728164637719-1038154879.png" alt="img" loading="lazy"></figure>
<ul>
<li>@ConfigurationProperties 只需要写一次即可 ， @Value则需要每个字段都添加</li>
<li>松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定</li>
<li>JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</li>
<li>复杂类型封装，yml中可以封装对象 ， 使用@Value就不支持</li>
</ul>
<h4 id="jsr303-数据校验">JSR303 数据校验</h4>
<p>SpringBoot 中可以用 @Validated 来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。</p>
<p>例如：</p>
<pre><code class="language-java">@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
@Validated
public class Person {
    @Email(message = &quot;邮箱错误&quot;)
    private String name;
}
</code></pre>
<p>当添加了该注解后，如果数据不为注解所需格式，则会在编译时进行报错。</p>
<h5 id="bean-validation-中内置的-constraint">Bean Validation 中内置的 constraint</h5>
<figure data-type="image" tabindex="6"><img src="https://upload-images.jianshu.io/upload_images/3145530-8ae74d19e6c65b4c?imageMogr2/auto-orient/strip%7CimageView2/2/w/654/format/webp" alt="img" loading="lazy"></figure>
<h5 id="hibernate-validator-附加的-constraint"><strong>Hibernate Validator 附加的 constraint</strong></h5>
<figure data-type="image" tabindex="7"><img src="https://upload-images.jianshu.io/upload_images/3145530-10035c6af8e90a7c?imageMogr2/auto-orient/strip%7CimageView2/2/w/432/format/webp" alt="img" loading="lazy"></figure>
<h3 id="多环境切换">多环境切换</h3>
<p>profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境 。</p>
<h4 id="方式一编写多个-properties-配置文件">方式一：编写多个 properties 配置文件</h4>
<p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml ， 用来指定多个环境版本；</p>
<p>例如：application-test.properties 代表测试环境配置  application-dev.properties 代表开发环境配置</p>
<p>但是Springboot并不会直接启动这些配置文件，它默认使用application.properties主配置文件；</p>
<p>我们需要通过一个配置来选择需要激活的环境；</p>
<pre><code class="language-properties">#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；
#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；
spring.profiles.active=dev
</code></pre>
<h4 id="方式二yaml-的多文档块">方式二：Yaml 的多文档块</h4>
<pre><code class="language-yaml"># --- 代表一个文档块

server:
  port: 8081
#选择要激活那个环境块
spring:
  profiles:
    active: dev

---
server:
  port: 8083
#配置环境的名称
spring:
  profiles: dev


---

server:
  port: 8084
spring:
  profiles: prod  #配置环境的名称
</code></pre>
<p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p>
<h3 id="配置文件加载位置">配置文件加载位置</h3>
<p><strong>Springboot 启动会扫描以下位置的 application.properties 或者 application.yaml 文件作为 Springboot 的默认配置文件</strong></p>
<pre><code>优先级1：项目路径下的config文件夹配置文件
优先级2：项目路径下配置文件
优先级3：资源路径下的config文件夹配置文件
优先级4：资源路径下配置文件
</code></pre>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置 ;</p>
<p><strong>SpringBoot会从这四个位置全部加载主配置文件；*<em>互补配置*</em>；</strong></p>
<h3 id="自动配置原理分析">自动配置原理分析</h3>
<ol>
<li>
<p>SpringBoot启动的时候加载主配置类，开启了自动配置功能 <strong>@EnableAutoConfiguration</strong></p>
</li>
<li>
<p><strong>@EnableAutoConfiguration</strong>  的作用：</p>
<ul>
<li>利用 <strong>@EnableAutoConfiguration</strong> 可以为容器中导入一些组件。</li>
<li>进入 <strong>@EnableAutoConfiguration</strong>  中，有一个 selectImports(AnnotationMetadata annotationMetadata) 方法，返回了一个数组，而数组中的值来自于 AutoConfigurationEntry ，通过调用 this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata) 能够获取 AutoConfigurationEntry 实例。</li>
<li>进入 getAutoConfigurationEntry 方法，其中有一个值为 List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);</li>
<li>进入 getCandidateConfigurations 方法，其中调用了SpringFactoriesLoader  的 loadFactoryNames 方法， 用于获取 configurations 的集合。</li>
<li>进入 loadFactoryNames 方法，发现它又调用了 loadSpringFactories 方法。</li>
<li>进入 loadSpringFactories 方法，发现它获取了一个定义变量名为 FACTORIES_RESOURCE_LOCATION 的资源文件，而资源文件内容指向 &quot;META-INF/spring.factories&quot;。 而后将读取到的资源封装在 url 中， 通过 while 循环，把这些 url 文件封装在 Properties 文件中，最后返回封装好的结果。</li>
<li><strong>总结：</strong>@EnableAutoConfiguration 作用就是从 classpath 中搜寻所有的 META-INF/spring.factories 配置文件，并将在 autoconfigure 的 jar 包下的  META-INF/spring.factories 中 EnableAutoConfiguration 中的所有对应配置项通过反射加载到IoC容器中。如果这些配置类要生效需要在 pom.xml 中引用。</li>
</ul>
</li>
<li>
<p>每一个自动配置类都可以进行自动配置。</p>
<ul>
<li>以 **HttpEncodingAutoConfiguration（Http编码自动配置）**为例 ：</li>
</ul>
<pre><code class="language-java">@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
//启动指定类的ConfigurationProperties功能；
//进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来；
//并把HttpProperties加入到ioc容器中
@EnableConfigurationProperties({HttpProperties.class}) 

//Spring底层@Conditional注解
//根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效；
//这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效
@ConditionalOnWebApplication(
    type = Type.SERVLET
)

//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；
@ConditionalOnClass({CharacterEncodingFilter.class})

//判断配置文件中是否存在某个配置：spring.http.encoding.enabled；
//如果不存在，判断也是成立的
//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
@ConditionalOnProperty(
    prefix = &quot;spring.http.encoding&quot;,
    value = {&quot;enabled&quot;},
    matchIfMissing = true
)
public class HttpEncodingAutoConfiguration {

    //他已经和SpringBoot的配置文件映射了
    private final Encoding properties;

    //只有一个有参构造器的情况下，参数的值就会从容器中拿
    public HttpEncodingAutoConfiguration(HttpProperties properties) {
        this.properties = properties.getEncoding();
    }

    //给容器中添加一个组件，这个组件的某些值需要从properties中获取
    @Bean
    @ConditionalOnMissingBean //判断容器没有这个组件？
    public CharacterEncodingFilter characterEncodingFilter() {
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.properties.getCharset().name());
        filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST));
        filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE));
        return filter;
    }
    ......
</code></pre>
<p>即：使用 SpringBoot 底层的 Condiction 注解，根据当前不同的条件进行判断，并决定这个配置类是否生效。</p>
<ul>
<li>@EnableConfigurationProperties 中的属性指向的 xxxProperties类都是封装者；</li>
</ul>
<pre><code class="language-java">@ConfigurationProperties(
    prefix = &quot;spring.http&quot;
) //从配置文件中获取指定的值和bean的属性进行绑定
public class HttpProperties {
    private boolean logRequestDetails;
    private final HttpProperties.Encoding encoding = new HttpProperties.Encoding();

    public HttpProperties() {
    }

    public boolean isLogRequestDetails() {
        return this.logRequestDetails;
    }

    public void setLogRequestDetails(boolean logRequestDetails) {
        this.logRequestDetails = logRequestDetails;
    }

    public HttpProperties.Encoding getEncoding() {
        return this.encoding;
    }

    public static class Encoding {
        public static final Charset DEFAULT_CHARSET;
        private Charset charset;
        private Boolean force;
        private Boolean forceRequest;
        private Boolean forceResponse;
        private Map&lt;Locale, Charset&gt; mapping;
        
        ......
    }
}
</code></pre>
</li>
</ol>
<h5 id="总结"><strong>总结：</strong></h5>
<p>(1) SpringBoot 在启动时，会加载大量的自动配置类。</p>
<p>(2) 当我们在 pom.xml 中进行依赖后，便会使自动装配的相应类生效。</p>
<p>(3) 当给容器中自动配置类添加组件的时候，会从相应的 properties 类中获取默认属性。我们可以通过配置文件对这些属性进行修改。</p>
<h5 id="conditional">@Conditional</h5>
<p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<figure data-type="image" tabindex="8"><img src="https://img2018.cnblogs.com/blog/1418974/201907/1418974-20190729005838066-64765389.png" alt="img" loading="lazy"></figure>
<p><strong>所以，加载的配置类不一定能够生效，可以在配置文件中使用 debug = ture，让控制台打印相关信息，其中：</strong></p>
<p>Positive matches:（自动配置类启用的：正匹配）</p>
<p>Negative matches:（没有启动，没有匹配成功的自动配置类：负匹配）</p>
<p>Unconditional classes: （没有条件的类）</p>
<h2 id="springboot-web开发">SpringBoot Web开发</h2>
<h3 id="静态资源映射规则">静态资源映射规则</h3>
<ul>
<li>
<p>SpringMVC 的 web 配置都在 WebMvcAutoConfiguration 中进行配置。</p>
</li>
<li>
<p>进入 WebMvcAutoConfiguration 的 WebMvcAutoConfigurationAdapter 中，可以看到其中的 addResourceHandlers 方法如下：</p>
<pre><code class="language-java">public void addResourceHandlers(ResourceHandlerRegistry registry) {
     if (!this.resourceProperties.isAddMappings()) {
        logger.debug(&quot;Default resource handling disabled&quot;);
     } else {
     Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
     CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();
      if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) {
                    this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{&quot;/webjars/**&quot;}).addResourceLocations(new String[]{&quot;classpath:/META-INF/resources/webjars/&quot;}).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));
                }

      String staticPathPattern = this.mvcProperties.getStaticPathPattern();
      if (!registry.hasMappingForPattern(staticPathPattern)) {
                    this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl));
                }

            }
        }
</code></pre>
</li>
<li>
<p>可知，一共有三种使用静态资源的方法</p>
</li>
</ul>
<ol>
<li>
<p>使用 webjars 方式引入静态资源。</p>
<p>网站：<a href="http://www.baidu.com/link?url=mIlNsV-6IxBMBhkb3lsHrSKJ7NkoQ2cZ5mFYAan6hOOApPrarTnv7O78tltep771">https://www.<strong>webjars</strong>.org/</a></p>
</li>
<li>
<p>将静态资源放置在默认路径下。</p>
<pre><code>&quot;classpath:/META-INF/resources/&quot;, 
&quot;classpath:/resources/&quot;,
 &quot;classpath:/static/&quot;, 
&quot;classpath:/public/&quot;,
&quot;/&quot; ：当前项目的根目录
</code></pre>
</li>
<li>
<p>通过配置文件自定义路径</p>
</li>
</ol>
<h3 id="模板引擎">模板引擎</h3>
<p>需要使用模板引擎，只需要在 pom.xml 中导入 themeleaf 的依赖，maven 会自动下载 jar 包。</p>
<pre><code class="language-xml">        &lt;!--thymeleaf模板--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;
            &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
            &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;
        &lt;/dependency&gt;

</code></pre>
<p>thymeleaf 的默认存放模板页面路径在  src/main/resources/templates  或者  src/main/view/templates 下。</p>
<h4 id="thymeleaf-语法">Thymeleaf 语法</h4>
<p>Thymeleaf 官网：https://www.thymeleaf.org/</p>
<p>在 Controller 中进行数据存放。</p>
<pre><code class="language-java">    @RequestMapping(&quot;/success&quot;)
    public String success(Model model){
        //存入数据
        model.addAttribute(&quot;msg&quot;,&quot;Hello,Thymeleaf&quot;);
        //classpath:/templates/success.html
        return &quot;success&quot;;
    }
</code></pre>
<p>在编写前端页面时，如果需要使用 Thymeleaf ， 需要在html文件中导入命名空间的约束。</p>
<pre><code class="language-html"> xmlns:th=&quot;http://www.thymeleaf.org&quot;
</code></pre>
<p>在 html 页面中取出数据。</p>
<pre><code class="language-html">&lt;body&gt;
&lt;h1&gt;Success&lt;/h1&gt;
&lt;!--th:text就是将div中的内容设置为它指定的值，和之前学习的Vue一样--&gt;
&lt;div th:text=&quot;${msg}&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<h5 id="使用-thattr-来替换-html-中原生的属性值">使用 th:attr 来替换 Html 中原生的属性值。</h5>
<figure data-type="image" tabindex="9"><img src="https://img2018.cnblogs.com/blog/1418974/201908/1418974-20190807235829953-1197701508.png" alt="img" loading="lazy"></figure>
<h5 id="模板布局">模板布局</h5>
<ol>
<li>
<p>通过 <code>th:fragment</code> 将页面的一部分引用为模板。如：<code>th:fragment=&quot;topbar&quot;</code></p>
</li>
<li>
<p>通过 <code>th:insert/th:replace</code> 将模板引入。如：<code>th:replace=&quot;~{commons/commons::topbar}</code></p>
</li>
<li>
<p>在引入模板时可以携带参数。如：<code>th:replace=&quot;~{commons/commons::sidebar(active='list.html')}&quot;</code></p>
</li>
<li>
<p>模板可以通过参数进行判断。如：<code>th:class=&quot;${active=='main.html'?'nav-link active':'nav-link'}&quot;</code></p>
</li>
</ol>
<h3 id="spring-mvc-自动配置">Spring MVC 自动配置</h3>
<h5 id="contentnegotiatingviewresolver">ContentNegotiatingViewResolver</h5>
<p>SpringBoot 帮我们的 SpringMVC 自动配置了视图解析器： 即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。</p>
<p>从  WebMvcAutoConfiguration  中搜索  ContentNegotiatingViewResolver ，可以找到如下方法：</p>
<pre><code class="language-java">@Bean //我们在这里确实看到已经给容器中注册了一个bean
@ConditionalOnBean({ViewResolver.class})
@ConditionalOnMissingBean(
     name = {&quot;viewResolver&quot;},
     value = {ContentNegotiatingViewResolver.class}
)
public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) {
     ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
     resolver.setContentNegotiationManager((ContentNegotiationManager)beanFactory.getBean(ContentNegotiationManager.class));
     resolver.setOrder(-2147483648);
     return resolver;
}

</code></pre>
<p>进入 ContentNegotiatingViewResolver 类中，可以在其中找到一个 resolveViewName 方法:</p>
<pre><code class="language-java">	@Override
	@Nullable
	public View resolveViewName(String viewName, Locale locale) throws Exception {
		RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
		Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;);
		List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());
		if (requestedMediaTypes != null) {
            //获取候选的视图对象
			List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);
            //选择一个最适合的视图对象，然后把这个对象返回
			View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);
			if (bestView != null) {
				return bestView;
			}
		}


</code></pre>
<p>在 getCandidateViews 中，通过循环遍历获取所有的视图解析器并解析。</p>
<p><strong>总结：</strong> ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的</p>
<h5 id="转换器和格式化器">转换器和格式化器</h5>
<p>我们可以通过在配置文件中配置日期格式化的规则达到对日期格式的限定的效果：</p>
<pre><code class="language-xml">spring.mvc.data-format = 

</code></pre>
<h5 id="扩展使用-springmvc">扩展使用 SpringMVC</h5>
<p>官方文档：</p>
<pre><code class="language-word">If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.

</code></pre>
<p>根据文档说明，我们需要编写一个 @Configuration 的注解类， 并且需要继承自 WebMvcConfigurer ，同时不能标注  @EnableWebMvc 。</p>
<p>注：@EnableWebMvc 会引入一个 DelegatingWebMvcConfiguration 类，他的父类为  WebMvcConfigurationSupport  ，而 Webmvc 自动配置类上有一个  @ConditionalOnMissingBean({WebMvcConfigurationSupport.class}) 注解，这个注解的意思是，当没有引入指定类时才可生效。</p>
<p>测试：</p>
<pre><code class="language-java">//应为类型要求为WebMvcConfigurer，所以我们实现其接口
//可以使用自定义类扩展MVC的功能
@Configuration
public class MyMvcConfig implements WebMvcConfigurer {

    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        //浏览器发送/test ， 就会跳转到success页面；
        registry.addViewController(&quot;/test&quot;).setViewName(&quot;success&quot;);
    }
}

</code></pre>
<p>所以，当需要扩展 SpringMVC 时，官方推荐使用这种方式，既可以保留原有的自动配置，又可以使用自定义扩展的配置。</p>
<p><strong>原理分析：</strong></p>
<ol>
<li>WebMvcAutoConfiguration 是 SpringMVC的自动配置类，其中有一个名为WebMvcAutoConfigurationAdapter 的类。</li>
<li>这个类上的注解，在做其他自动配置时会导入：  @Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class})</li>
<li>进入  EnableWebMvcConfiguration 中，继承了一个名为  DelegatingWebMvcConfiguration 的父类，这个父类中存在：</li>
</ol>
<pre><code class="language-java">    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();

　　 //从容器中获取所有的webmvcConfigurer
    @Autowired(required = false)
    public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) {
        if (!CollectionUtils.isEmpty(configurers)) {
            this.configurers.addWebMvcConfigurers(configurers);
        }

    }

</code></pre>
<p>而我们设置的 viewController 中，使用了一个方法：</p>
<pre><code class="language-java">this.configurers.addViewControllers(registry);

</code></pre>
<p>这个方法的源代码为：</p>
<pre><code class="language-java">    public void addViewControllers(ViewControllerRegistry registry) {
        Iterator var2 = this.delegates.iterator();

        while(var2.hasNext()) {
            //将所有的WebMvcConfigurer相关配置来一起调用！包括我们自己配置的和Spring给我们配置的
            WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next();
            delegate.addViewControllers(registry);
        }
    }

</code></pre>
<ol start="5">
<li>所以，所有的 WebMvcConfiguration 都会被使用，包括我们自定义的。</li>
</ol>
<h5 id="国际化">国际化</h5>
<ol>
<li>在 resources 目录下新建 i18n 文件，其中存放国际化使用的 properties 文件。</li>
</ol>
<pre><code class="language-properties"># login.properties
login.btn=登录
login.password=密码
login.remember=记住我
login.tip=请登录
login.username=用户名

</code></pre>
<ol start="2">
<li>在前端页面使用按钮进行切换(#{})，并且编写自定义类继承自 LocaleResolver</li>
</ol>
<pre><code class="language-html">&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html(lang='zh_CN')}&quot;&gt;中文&lt;/a&gt;
&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/index.html(lang='en_US')}&quot;&gt;English&lt;/a&gt;

</code></pre>
<pre><code class="language-java">public class MyLocaleResolver implements LocaleResolver {
    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        //获取请求中的语言参数
        String lang = request.getParameter(&quot;lang&quot;);
        Locale locale = Locale.getDefault();//如果没有携带参数则使用默认地区解析器
        //如果请求中携带了国际化参数
        if (!StringUtils.isEmpty(lang)){
            //zh_CN
            String[] split = lang.split(&quot;_&quot;);
            locale = new Locale(split[0],split[1]);
        }
        return locale;
    }

    @Override
    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {

    }
}

</code></pre>
<ol start="3">
<li>将编写的自定义类配置到 spring 容器中(@Bean)。</li>
</ol>
<h5 id="拦截器">拦截器</h5>
<ol>
<li>编写自定义类继承自 <code>HandlerInterceptor</code>;</li>
<li>重写不同方法，以设置拦截内容；</li>
<li>通过 <code>addInterceptors</code> 方法进行注入；</li>
</ol>
<pre><code class="language-java">//自定义拦截器
public class LoginHandlerInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //登录之后应当存在用户session
        Object loginUser = request.getSession().getAttribute(&quot;loginUser&quot;);

        if(loginUser == null){
            request.setAttribute(&quot;msg&quot;,&quot;没有权限，请登录&quot;);
            request.getRequestDispatcher(&quot;/index.html&quot;).forward(request,response);
            return false;
        }else {
            return true;
        }
    }
}

</code></pre>
<pre><code class="language-java">//注入
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new 	LoginHandlerInterceptor()).addPathPatterns(&quot;/**&quot;)
    .excludePathPatterns(&quot;/index.html&quot;,&quot;/&quot;,&quot;/user/login&quot;,&quot;/css/**&quot;,
                        &quot;/js/**&quot;,&quot;img/**&quot;);
}

</code></pre>
<h2 id="数据访问">数据访问</h2>
<p>对于数据访问层，无论是 SQL(关系型数据库) 还是 NOSQL(非关系型数据库)，Spring Boot 底层都是采用 Spring Data 的方式进行统一处理。</p>
<p>Spring Boot 底层都是采用 Spring Data 的方式进行统一处理各种数据库，Spring Data 也是 Spring 中与 Spring Boot、Spring Cloud 等齐名的知名项目。</p>
<p>Sping Data 官网：https://spring.io/projects/spring-data</p>
<p>数据库相关的启动器 ： 可以参考官方文档：<a href="https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#using-boot-starter">https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/reference/htmlsingle/#using-boot-starter</a></p>
<h3 id="jdbc">JDBC</h3>
<ol>
<li>在 pom.xml 中添加依赖</li>
</ol>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;

</code></pre>
<ol start="2">
<li>在配置文件中进行配置</li>
</ol>
<pre><code class="language-yml"># application.yml
spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver

</code></pre>
<ol start="3">
<li>使用( SpringBoot 自动配置)</li>
</ol>
<p>默认数据源为 hikari</p>
<pre><code class="language-java">@RestController
public class JDBCController {
    @Autowired
    JdbcTemplate jdbcTemplate;

    @GetMapping(&quot;/userList&quot;)
    public List&lt;Map&lt;String,Object&gt;&gt; userList(){
        String sql = &quot;select * from user&quot;;
        List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql);
        return maps;
    }

    @GetMapping(&quot;/updateUser/{id}&quot;)
    public String updateUser(@PathVariable(&quot;id&quot;) int id){
        String sql = &quot;update mybatis.user set name=?,pwd=? where id = &quot; + id;
        //封装
        Object[] objects = new Object[2];
        objects[0] = &quot;小明2&quot;;
        objects[1] = &quot;zzzzzzzzz&quot;;
        jdbcTemplate.update(sql,objects);
        return &quot;updateUser-ok&quot;;

    }

    @GetMapping(&quot;/deleteUser/{id}&quot;)
    public String deleteUser(@PathVariable(&quot;id&quot;) int id){
        String sql = &quot;delete from mybatis.user where id = ?&quot;;
        jdbcTemplate.update(sql,id);
        return &quot;deleteUser-ok&quot;;
    }
}


</code></pre>
<p><strong>总结：</strong></p>
<p>1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用连接和原生的 JDBC 语句来操作数据库</p>
<p>2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即 org.springframework.jdbc.core.JdbcTemplate。</p>
<p>3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。</p>
<p>4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用</p>
<p>5、JdbcTemplate 的自动配置原理是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration 类</p>
<p><strong>JdbcTemplate主要提供以下几类方法：</strong></p>
<ul>
<li>execute方法：可以用于执行任何SQL语句，一般用于执行DDL语句；</li>
<li>update方法及batchUpdate方法：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</li>
<li>query方法及queryForXXX方法：用于执行查询相关语句；</li>
<li>call方法：用于执行存储过程、函数相关语句。</li>
</ul>
<h3 id="druid">Druid</h3>
<p><strong>DRUID 简介</strong></p>
<p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，结合了 C3P0、DBCP、PROXOOL 等 DB 池的优点，同时加入了日志监控。</p>
<p>Druid 可以很好的监控 DB 池连接和 SQL 的执行情况，天生就是针对监控而生的 DB 连接池。</p>
<p>Spring Boot 2.0 以上默认使用 Hikari 数据源，可以说 Hikari 与 Driud 都是当前 Java Web 上最优秀的数据源，我们来重点介绍 Spring Boot 如何集成 Druid 数据源，如何实现数据库监控。</p>
<p><strong>Druid 使用</strong></p>
<ol>
<li>引入数据源</li>
</ol>
<pre><code class="language-xml">&lt;!-- 在 pom.xml 中添加 Druid 依赖--&gt;
&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.1.21&lt;/version&gt;
        &lt;/dependency&gt;

</code></pre>
<ol start="2">
<li>在 application.yml 文件中设置配置项</li>
</ol>
<pre><code class="language-yml">spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
    type: com.alibaba.druid.pool.DruidDataSource

    #Spring Boot 默认是不注入这些属性值的，需要自己绑定
    #druid 数据源专有配置
    initialSize: 5
    minIdle: 5
    maxActive: 20
    maxWait: 60000
    timeBetweenEvictionRunsMillis: 60000
    minEvictableIdleTimeMillis: 300000
    validationQuery: SELECT 1 FROM DUAL
    testWhileIdle: true
    testOnBorrow: false
    testOnReturn: false
    poolPreparedStatements: true
    #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入
    #如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority
    #则导入 log4j 依赖即可，Maven 地址： https://mvnrepository.com/artifact/log4j/log4j
    filters: stat,wall,log4j
    maxPoolPreparedStatementPerConnectionSize: 20
    useGlobalDataSourceStat: true
    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500

</code></pre>
<p>注意：需要导入 log4j 的依赖。</p>
<ol start="3">
<li>编写配置类。</li>
</ol>
<pre><code class="language-java">@Configuration
public class DruidConfig {
    /*
       将自定义的 Druid数据源添加到容器中，不再让 Spring Boot 自动创建
       绑定全局配置文件中的 druid 数据源属性到 com.alibaba.druid.pool.DruidDataSource从而让它们生效
       @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)：作用就是将 全局配置文件中
       前缀为 spring.datasource的属性值注入到 com.alibaba.druid.pool.DruidDataSource 的同名参数中
     */
    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    @Bean
    public DataSource druidDataSource() {
        return new DruidDataSource();
    }

    //配置 Druid 监控管理后台的Servlet；
    //内置 Servlet 容器时没有web.xml文件，所以使用 SpringBoot 的注册 Servlet 方式
    @Bean
    public ServletRegistrationBean statViewServlet(){
        ServletRegistrationBean&lt;StatViewServlet&gt; bean  = new ServletRegistrationBean&lt;&gt;(new StatViewServlet());

        //后台需要有人登录，账号密码配置
        HashMap&lt;String ,String&gt; initParameters = new HashMap&lt;&gt;();

        //增加配置
        initParameters.put(&quot;loginUsername&quot;,&quot;admin&quot;);
        initParameters.put(&quot;loginPassword&quot;,&quot;123456&quot;);

        initParameters.put(&quot;allow&quot;,&quot;&quot;);

        bean.setInitParameters(initParameters);

        return bean;
    }


    @Bean
    public FilterRegistrationBean webStatFilter(){
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());

        //可以过滤的请求
        Map&lt;String,String&gt; initParameters = new HashMap&lt;&gt;();
        //不进行统计
        initParameters.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);
        bean.setInitParameters(initParameters);

        return bean;
    }
}

</code></pre>
<p>完成，可以通过  http://localhost:8080/druid/login.html  进入后台页面。</p>
<h3 id="整合-mybatis">整合 Mybatis</h3>
<ol>
<li>导入 Mybatis 所需要的依赖</li>
</ol>
<pre><code class="language-xml">        &lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;

</code></pre>
<ol start="2">
<li>配置数据库连接信息</li>
</ol>
<pre><code class="language-yml">spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8
    driver-class-name: com.mysql.cj.jdbc.Driver
mybatis:
  mapper-locations: classpath:mybatis/mapper/*.xml
  type-aliases-package: com.squid.pojo


</code></pre>
<ol start="3">
<li>创建实体类</li>
<li>配置 Mapper 接口</li>
</ol>
<pre><code class="language-java">@Mapper
@Repository
public interface UserMapper {
    List&lt;User&gt; queryUserList();
    User queryUserById(int id);
    int addUser(User user);
    int updateUser(User user);
    int deleteUser(int id);
}

</code></pre>
<ol start="5">
<li>Mapper 映射文件</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.squid.mapper.UserMapper&quot;&gt;
    &lt;select id=&quot;queryUserList&quot; resultType=&quot;User&quot;&gt;
        select * from user
    &lt;/select&gt;

    &lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;

    &lt;insert id=&quot;addUser&quot; parameterType=&quot;User&quot;&gt;
    insert into user (id,name,pwd) values (#{id},#{name},#{pwd})
&lt;/insert&gt;

    &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt;
    update user set name=#{name},pwd=#{pwd} where id = #{id}
&lt;/update&gt;

    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
&lt;/mapper&gt;

</code></pre>
<ol start="6">
<li>编写Controller</li>
</ol>
<pre><code class="language-java">@RestController
public class UserController {

    @Autowired
    private UserMapper userMapper;

    //选择全部用户
    @GetMapping(&quot;/selectUser&quot;)
    public String selectUser(){
        List&lt;User&gt; users = userMapper.selectUser();
        for (User user : users) {
            System.out.println(user);
        }

        return &quot;ok&quot;;
    }
    //根据id选择用户
    @GetMapping(&quot;/selectUserById&quot;)
    public String selectUserById(){
        User user = userMapper.selectUserById(1);
        System.out.println(user);
        return &quot;ok&quot;;
    }
    //添加一个用户
    @GetMapping(&quot;/addUser&quot;)
    public String addUser(){
        userMapper.addUser(new User(5,&quot;阿毛&quot;,&quot;456789&quot;));
        return &quot;ok&quot;;
    }
    //修改一个用户
    @GetMapping(&quot;/updateUser&quot;)
    public String updateUser(){
        userMapper.updateUser(new User(5,&quot;阿毛&quot;,&quot;421319&quot;));
        return &quot;ok&quot;;
    }
    //根据id删除用户
    @GetMapping(&quot;/deleteUser&quot;)
    public String deleteUser(){
        userMapper.deleteUser(5);
        return &quot;ok&quot;;
    }

}

</code></pre>
<h2 id="安全框架">安全框架</h2>
<h3 id="springsecurity">SpringSecurity</h3>
<ol>
<li>导入 SpringSecurity 依赖。</li>
</ol>
<pre><code class="language-xml">        &lt;!-- https://mvnrepository.com/artifact/org.thymeleaf.extras/thymeleaf-extras-springsecurity4 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
            &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt;
            &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

</code></pre>
<ol start="2">
<li>编写配置类。</li>
</ol>
<pre><code class="language-java">//AOP:拦截器
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    //链式编程

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers(&quot;/&quot;).permitAll()   //这个页面所有人都可以访问
                .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)  //限制角色访问
                .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)
                .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;);

        //没有权限默认跳转至登录页
        http.formLogin();

        //开启注销功能
        http.csrf().disable();//关闭csrf
        http.logout().logoutSuccessUrl(&quot;/&quot;);
                    
        //记住我
        http.rememberMe();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())
                .withUser(&quot;squid&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip2&quot;,&quot;vip3&quot;)
                .and()
                .withUser(&quot;root&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;,&quot;vip2&quot;,&quot;vip3&quot;)
                .and()
                .withUser(&quot;guest&quot;).password(new BCryptPasswordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;);
    }
}

</code></pre>
<ol start="3">
<li>与 Thymeleaf 整合</li>
</ol>
<pre><code class="language-html">xmlns:sec=&quot;http://www.thymeleaf.org/thymeleaf-extras-springsecurity4&quot;

</code></pre>
<p><strong>总结：</strong></p>
<p>需要记住的几个类：</p>
<ul>
<li>WebSecurityConfigurerAdapter：自定义 Security 策略</li>
<li>AuthenticationManagerBuilder：自定义认证策略</li>
<li>@EnableWebSecurity：开启 WebSecurity 模式，@Enablexxxx 开启某个功能</li>
</ul>
<p>SpringSecurity 主要的两个目标是“认证”和“授权”（控制访问）</p>
<p>“认证”（Authentication）</p>
<p>“授权”（Authorization）</p>
<h3 id="shiro">Shiro</h3>
<h4 id="简介">简介：</h4>
<p>Shiro是一个Java安全框架，执行身份验证、授权、密码、会话管理。Shiro是Apache 的一个开源项目，前身是JSecurity 项目，始于2003年初。</p>
<p>Shiro 可以为任何应用提供安全保障 - 从命令行应用、移动应用到大型网络及企业应用。</p>
<p>Shiro 解决了应用安全的四要素：</p>
<ul>
<li>认证 - 用户身份识别，常被称为用户“登录”；</li>
<li>授权 - 访问控制；</li>
<li>密码加密 - 保护或隐藏数据防止被偷窥；</li>
<li>会话管理 - 每用户相关的时间敏感的状态。</li>
</ul>
<h4 id="核心概念">核心概念</h4>
<p><strong>Subject</strong>：主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者；</p>
<p><strong>SecurityManager</strong>：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器；</p>
<p><strong>Realm</strong>：域，Shiro从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。</p>
<figure data-type="image" tabindex="10"><img src="https://images2018.cnblogs.com/blog/1147108/201806/1147108-20180627204048502-115811133.png" alt="img" loading="lazy"></figure>
<h4 id="快速开始">快速开始：</h4>
<ol>
<li>导入依赖</li>
</ol>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
            &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;
            &lt;version&gt;1.4.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- configure logging --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
            &lt;version&gt;1.7.21&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;1.7.21&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j&lt;/artifactId&gt;
            &lt;version&gt;1.2.17&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

</code></pre>
<ol start="2">
<li>配置文件</li>
</ol>
<pre><code class="language-properties">log4j.rootLogger=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m %n

# General Apache libraries
log4j.logger.org.apache=WARN

# Spring
log4j.logger.org.springframework=WARN

# Default Shiro logging
log4j.logger.org.apache.shiro=TRACE

# Disable verbose logging
log4j.logger.org.apache.shiro.util.ThreadContext=WARN
log4j.logger.org.apache.shiro.cache.ehcache.EhCache=WARN

</code></pre>
<pre><code class="language-ini">[users]
# user 'root' with password 'secret' and the 'admin' role
root = secret, admin
# user 'guest' with the password 'guest' and the 'guest' role
guest = guest, guest
# user 'presidentskroob' with password '12345' (&quot;That's the same combination on
# my luggage!!!&quot; ;)), and role 'president'
presidentskroob = 12345, president
# user 'darkhelmet' with password 'ludicrousspeed' and roles 'darklord' and 'schwartz'
darkhelmet = ludicrousspeed, darklord, schwartz
# user 'lonestarr' with password 'vespa' and roles 'goodguy' and 'schwartz'
lonestarr = vespa, goodguy, schwartz

# -----------------------------------------------------------------------------
# Roles with assigned permissions
#
# Each line conforms to the format defined in the
# org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc
# -----------------------------------------------------------------------------
[roles]
# 'admin' role has all permissions, indicated by the wildcard '*'
admin = *
# The 'schwartz' role can do anything (*) with any lightsaber:
schwartz = lightsaber:*
# The 'goodguy' role is allowed to 'drive' (action) the winnebago (type) with
# license plate 'eagle5' (instance specific id)
goodguy = winnebago:drive:eagle5

</code></pre>
<ol start="3">
<li>编写类</li>
</ol>
<pre><code class="language-java">//重要方法
Subject currentUser = SecurityUtils.getSubject();	//获取当前用户对象Subject
Session session = currentUser.getSession();	//通过当前用户对象获取session（shiro的session）
currentUser.isAuthenticated()	// 判断当前对象是否已经过认证
UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);	//令牌
currentUser.getPrincipal()	//当前用户认证
currentUser.hasRole(&quot;schwartz&quot;)	//是否拥有角色
currentUser.logout();	//注销

</code></pre>
<h4 id="shiro-整合-springboot">Shiro 整合 SpringBoot</h4>
<ol>
<li>导入依赖</li>
</ol>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
    &lt;version&gt;1.4.1&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
<ol start="2">
<li>自定义 realm 对象</li>
</ol>
<pre><code class="language-java">//自定义 realm 对象
public class UserRealm extends AuthorizingRealm {
    @Autowired
    UserMapper userMapper;

    //授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        System.out.println(&quot;执行了=&gt;授权doGetAuthorizationInfo&quot;);

        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();

        //拿到当前对象
        Subject subject = SecurityUtils.getSubject();
        User currentUser = (User) subject.getPrincipal();   //拿到User对象
        info.addStringPermission(currentUser.getPerms());

        return info;
    }

    //认证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        System.out.println(&quot;执行了=&gt;认证doGetAuthenticationInfo&quot;);

        UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken)token;

        //用户名，密码从数据库中读取
        User user = userMapper.queryUserByName(usernamePasswordToken.getUsername());

        if (user == null){
            return null;
        }

        Subject subject = SecurityUtils.getSubject();
        Session session = subject.getSession();
        session.setAttribute(&quot;loginUser&quot;,user);
        
        //密码认证
        return new SimpleAuthenticationInfo(user,user.getPwd(),&quot;&quot;);
    }
}

</code></pre>
<ol start="3">
<li>编写 Shiro 的 config 类</li>
</ol>
<pre><code class="language-java">@Configuration
public class ShiroConfig {

    //ShiroFilterFactoryBean 3
    @Bean
    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;)DefaultWebSecurityManager defaultWebSecurityManager){
        ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();
        //设置安全管理器
        bean.setSecurityManager(defaultWebSecurityManager);

        //添加 Shiro 过滤器
        /*
            anon: 无需认证即可访问
            authc: 必须认证了才可以访问
            user: 必须拥有记住账号才可以访问
            perms: 拥有对某个资源的权限才可以访问
            role: 拥有某个角色权限才可以访问
        */
        //拦截
        Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;();
        filterMap.put(&quot;/user/add&quot;,&quot;perms[user:add]&quot;);
        filterMap.put(&quot;/user/update&quot;,&quot;perms[user:update]&quot;);
        filterMap.put(&quot;/user/*&quot;,&quot;authc&quot;);
        bean.setFilterChainDefinitionMap(filterMap);

        //设置登录请求
        bean.setLoginUrl(&quot;/toLogin&quot;);

        bean.setUnauthorizedUrl(&quot;/noauth&quot;);

        return bean;
    }

    //DefaultWebSecurityManager 2
    @Bean(name = &quot;securityManager&quot;)
    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm){
        DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();
        //关联 UserRealm
        defaultWebSecurityManager.setRealm(userRealm);
        return defaultWebSecurityManager;
    }

    //创建 realm 对象，需要自定义类 1
    @Bean
    public UserRealm userRealm(){
        return new UserRealm();
    }
    
    
    @Bean
    public ShiroDialect getShiroDialect(){
        return new ShiroDialect();
    }
}

</code></pre>
<ol start="4">
<li>在 Controller 中进行认证</li>
</ol>
<pre><code class="language-java"> @RequestMapping(&quot;/login&quot;)
    public String login(String username,String password,Model model){
        //获取当前用户
        org.apache.shiro.subject.Subject subject = SecurityUtils.getSubject();
        //封装用户的登录数据
        UsernamePasswordToken token = new UsernamePasswordToken(username,password);

        try {
            subject.login(token);//执行登录方法
            return &quot;index&quot;;
        } catch (UnknownAccountException e) {
            model.addAttribute(&quot;msg&quot;,&quot;用户名错误&quot;);
            return &quot;login&quot;;
        }catch (IncorrectCredentialsException e){
            model.addAttribute(&quot;msg&quot;,&quot;密码错误&quot;);
            return &quot;login&quot;;
        }
    }

</code></pre>
<h4 id="shiro-整合-thymeleaf">Shiro 整合 Thymeleaf</h4>
<ol>
<li>导入依赖</li>
</ol>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/com.github.theborakompanioni/thymeleaf-extras-shiro --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt;
    &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
&lt;/dependency&gt;


</code></pre>
<ol start="2">
<li>加入头文件</li>
</ol>
<pre><code class="language-html">xmlns:shiro=&quot;http://www.thymeleaf.org/thymeleaf-extras-shiro&quot;

</code></pre>
<ol start="3">
<li>前端使用 shiro 操作</li>
</ol>
<pre><code class="language-html">shiro:hasPermission=&quot;user:add&quot;

</code></pre>
<h2 id="swagger">Swagger</h2>
<h3 id="介绍">介绍：</h3>
<p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p>
<p>作用：</p>
<p><strong>1.接口的文档在线自动生成。</strong></p>
<p><strong>2.功能测试。</strong></p>
<h3 id="在-springboot-中使用-swagger">在 SpringBoot 中使用 Swagger</h3>
<ol>
<li>导入两个依赖</li>
</ol>
<pre><code class="language-xml">&lt;!-- springfox-swagger2 --&gt;
&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.springfox&lt;/groupId&gt;
    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
    &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
<pre><code class="language-xml">&lt;!-- springfox-swagger-ui --&gt;
&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.springfox&lt;/groupId&gt;
    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
    &lt;version&gt;2.9.2&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
<ol start="2">
<li>编写集成类</li>
</ol>
<pre><code class="language-java">@Configuration
@EnableSwagger2 //开启 Swagger2
public class SwaggerConfig {
}

</code></pre>
<ol start="3">
<li>进入 http://localhost:8080/swagger-ui.html</li>
</ol>
<h3 id="配置-swagger-信息">配置 Swagger 信息</h3>
<pre><code class="language-java">//SwaggerConfig
@Configuration
@EnableSwagger2 //开启 Swagger2
public class SwaggerConfig {

    //配置了 Swagger 的 Docket 的 bean 实例
    @Bean
    public Docket docket(){
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo());
    }

    //配置 Swagger 信息 = ApiInfo
    private ApiInfo apiInfo(){

        //作者信息
        Contact contact = new Contact(&quot;Squid&quot;,&quot;&quot;,&quot;502087277@qq.com&quot;);

        return new ApiInfo(
                &quot;Squid的Swagger文档&quot;,
                &quot;You only got one shot&quot;,
                &quot;v1.0&quot;,
                &quot;http://localhost:8080&quot;,
                contact,
                &quot;Aapche 2.0&quot;,
                &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;,
                new ArrayList());
    }
}

</code></pre>
<h3 id="配置-swagger-配置扫描接口">配置 Swagger 配置扫描接口</h3>
<pre><code class="language-java">    //配置了 Swagger 的 Docket 的 bean 实例
    @Bean
    public Docket docket(Environment environment){

        //设置要显示的Swagger环境
        Profiles profiles = Profiles.of(&quot;dev&quot;);

        //获取项目环境 并判断是否在当前指定的环境中
        boolean flag = environment.acceptsProfiles(profiles);

        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
//                .enable(flag)    是否启用 Swagger
                .select()
                //RequestHandlerSelectors,配置要扫描的方式
                //basePackage 指定扫描包
                //any   扫描全部
                //none  都不扫描
                //withClassAnnotation   扫描类上的注解
                .apis(RequestHandlerSelectors.basePackage(&quot;&quot;))
                //过滤
                .paths(PathSelectors.any())
                .build();
    }

</code></pre>
<h3 id="配置-api-文档的分组">配置 API 文档的分组</h3>
<pre><code class="language-java">.groupName(&quot;分组1&quot;)

</code></pre>
<p>如果需要多个分组，编写多个 Docket 即可。</p>
<p><strong>注解：</strong></p>
<pre><code>@Api : 用在类上，说明该类的主要作用。

@ApiOperation：用在方法上，给API增加方法说明。

@ApiImplicitParams : 用在方法上，包含一组参数说明。

@ApiImplicitParam：用来注解来给方法入参增加说明。

@ApiResponses：用于表示一组响应。

@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息

@ApiModel：用在返回对象类上，描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）

@ApiModelProperty：描述一个model的属性

</code></pre>
<h2 id="任务">任务</h2>
<h3 id="异步任务">异步任务</h3>
<ol>
<li>
<p>在需要异步的方法上加上注解 @Async</p>
</li>
<li>
<p>在 Main 方法上加上注解 @EnableAsync</p>
</li>
</ol>
<h3 id="邮件任务">邮件任务</h3>
<ol>
<li>导入 mail 依赖</li>
</ol>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
        &lt;/dependency&gt;

</code></pre>
<ol start="2">
<li>在 application 文件中进行配置</li>
</ol>
<pre><code class="language-propertie">spring.mail.username=502087277@qq.com
spring.mail.password=wzqqhkjscfyrbidi
spring.mail.host=smtp.qq.com
# 开启加密验证
spring.mail.properties.mail.smtp.ssl.enable=true

</code></pre>
<ol start="3">
<li>发送邮件</li>
</ol>
<p><strong>简单邮件：</strong></p>
<pre><code class="language-java">    @Autowired
    JavaMailSenderImpl mailSender;

		//一个简单的邮件
        SimpleMailMessage mailMessage = new SimpleMailMessage();
        mailMessage.setSubject(&quot;亲爱的 Squid！你好&quot;);
        mailMessage.setText(&quot;感谢秦老师的课程&quot;);
        mailMessage.setTo(&quot;502087277@qq.com&quot;);
        mailMessage.setFrom(&quot;502087277@qq.com&quot;);
        mailSender.send(mailMessage);

</code></pre>
<p><strong>复杂邮件：</strong></p>
<pre><code class="language-java">        //一个复杂邮件
        MimeMessage mimeMessage = mailSender.createMimeMessage();
        //组装
        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage,true);

        helper.setSubject(&quot;亲爱的 Squid！ 你好呀~&quot;);
        helper.setText(&quot;&lt;p style='color:red'&gt;感谢秦老师的课程&lt;/p&gt;&quot;,true);

        //附件
        helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;F:\\素材\\主界面\\home_page_back.png&quot;));

        helper.setTo(&quot;502087277@qq.com&quot;);
        helper.setFrom(&quot;502087277@qq.com&quot;);

        mailSender.send(mimeMessage);

</code></pre>
<h3 id="定时任务">定时任务</h3>
<ol>
<li>在 main 方法上添加注解 @EnableScheduling</li>
<li>使用 @Scheduled 表示什么时候执行（使用 cron 表达式）</li>
</ol>
<p>cron 表达式参考： https://www.cnblogs.com/tommyli/p/3760671.html</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://liuyuzheng8.github.io/tag/aA-yofVdw/" class="tag">
                    框架
                  </a>
                
              </div>
            
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
